# Invoice Validation App Analysis

## Document Summary
This document captures the complete analysis of the CrossBoundary Energy (CBE) Invoice Validation App, including code review, data architecture explanation, real-world interpretation of the data files, reverse-engineered Snowflake schema with complete table inventory, a function-by-function code map, and privacy considerations for using Claude with sensitive business data.

---

## 1. Application Overview

### Purpose
The **Sage Invoice Validation App** is a Streamlit-based internal tool designed for an **Asset Management / Finance team** to validate invoices generated by their **Sage ERP system**. The application independently recalculates what invoice amounts *should* be based on raw contract pricing and meter readings, then compares those calculated values against what Sage actually produced.

**Core business problem it solves:** *"Are the invoices Sage is generating correct?"*

This app provides an independent check: "Based on the raw data, here's what the invoice should be. Here's what Sage says. Do they match?"

### The Business Context
CrossBoundary Energy (CBE) is a **commercial and industrial solar energy company** operating across Africa and other emerging markets. They install solar panels, battery storage (BESS), and generators at customer facilities, then bill customers for the energy consumed.

---

## 2. Inputs and Outputs

### Inputs

| Input Type | Source | Description |
|------------|--------|-------------|
| **Contract data** | Snowflake data warehouse | Active contracts with customer info, currency, facility |
| **Pricing configuration** | Snowflake | Gross prices, discount tiers (1-3), floor/ceiling tariffs in USD and local currency |
| **Meter readings** | Snowflake | Opening/closing readings, utilized reading, discount readings, sourced energy |
| **Sage invoices** | Snowflake | Actual invoices generated by the Sage system |
| **Exchange rates** | Manual input + Snowflake | USD-to-local currency rates (user-editable, persisted to warehouse) |
| **Invoice month** | User selection | Which billing period to validate |

### Outputs

1. **Validation comparison table** — Side-by-side view of calculated vs. actual invoice amounts with a `VALIDATED` boolean flag
2. **Percentage difference calculations** — Both in local currency and USD
3. **Subtotals by product group** — Aggregated by the first two characters of product codes
4. **Downloadable CSV** — Export for offline analysis
5. **Detailed drill-down** — Per-customer breakdown showing pricing, meter readings, and invoice details

---

## 3. Key Functionalities

### Section 1: Contract Pricing Adjustments Tracker
Shows upcoming and recent price adjustment dates, helping the team anticipate when contracts will change pricing based on configured frequencies (monthly, yearly).

### Section 2: Contract Change History
Displays what pricing changes have been made in the last 3 months for a selected customer — useful for auditing why an invoice might differ from expectations.

### Section 3: Invoice Validation Engine
The core logic:
- Pulls current pricing (gross price minus discounts, bounded by floor/ceiling tariffs)
- Pulls meter readings for the period
- Calculates expected invoice = `FINAL_PRICE × ADJUSTED_METER_READING`
- Compares to Sage's actual invoice at 4 decimal places

### Section 4: Exchange Rate Management
Interactive table for users to input/update exchange rates, which are persisted to the warehouse for reuse.

### Dual Calculation Methods
The app explicitly calculates invoices two ways to detect discrepancies:
- **CBE method**: Adjust the meter reading, multiply by price
- **Sage method**: Adjust the price by a ratio, multiply by original reading (causes rounding errors at high volumes)

---

## 4. Data Architecture

### What is a Dimensional Data Warehouse (Kimball-style)?

The Kimball approach (named after Ralph Kimball, a data warehousing pioneer) organizes data into two types of tables that work together:

1. **"What happened" tables (Facts)** — The transactions, the events, the measurements
   - Example: "On January 15, we sold 3 copies of Book #472 to Customer #891 for $45"

2. **"What things are" tables (Dimensions)** — The descriptive details about the things involved
   - Example: Book #472 is "The Great Gatsby", Fiction, published 1925, by F. Scott Fitzgerald

**Why do this?**
- You don't repeat descriptive data on every single transaction record
- When you need to analyze data, you can easily join the pieces together
- If an attribute changes, you update it in one place

### Dimension Tables vs Fact Tables

| Aspect | Dimension Tables (`dim_*`) | Fact Tables (`fct_*`) |
|--------|---------------------------|----------------------|
| **Contains** | Descriptive attributes | Measurements/metrics |
| **Changes** | Slowly (a customer's name rarely changes) | Constantly (new transactions every day) |
| **Row count** | Relatively small (thousands) | Very large (millions/billions) |
| **Example data** | Customer name, address, product description | Quantities, prices, readings, amounts |
| **Question answered** | "What is this thing?" | "What happened?" |

### Type 2 Slowly Changing Dimension (SCD)

**The problem:** Things change over time. A customer moves. A product's price changes. A contract gets amended. How do you track history?

**Type 2 SCD solution:** Keep every version of the record, mark which one is current.

**Example — Customer address changes:**

| CUSTOMER_ID | NAME | ADDRESS | DIM_CURRENT_RECORD | EFFECTIVE_START | EFFECTIVE_END |
|-------------|------|---------|-------------------|-----------------|---------------|
| 1 | Jane Smith | 123 Oak St, Chicago | 0 | 2020-01-01 | 2024-06-15 |
| 1 | Jane Smith | 456 Maple Ave, Boston | 1 | 2024-06-15 | 9999-12-31 |

- `DIM_CURRENT_RECORD = 1` means "this is the current truth"
- `DIM_CURRENT_RECORD = 0` means "this was true historically"
- The date fields tell you *when* each version was valid

**Why this matters for invoice validation:**
If you're validating January's invoice but the contract pricing was updated in February, you need to use *January's pricing*, not today's pricing. Type 2 SCD lets you "time travel" to see what the data looked like at any point in the past.

---

## 5. Data Structure Details

### Where Discounts and Floor/Ceiling Tariffs Are Stored

**Stored in Snowflake, not user inputs.** They're part of the contract configuration that someone (likely a contracts administrator) entered into the Sage ERP system, which then flows into the data warehouse.

The app queries for these specific measures:
```
'GROSS_PRICE_contract_lines',
'DISCOUNT_1_contract_lines',
'DISCOUNT_2_contract_lines', 
'DISCOUNT_3_contract_lines',
'CEILING_TARIFF_LOCAL_contract_lines',
'FLOOR_TARIFF_LOCAL_contract_lines',
'CEILING_TARIFF_USD_contract_lines',
'FLOOR_TARIFF_USD_contract_lines'
```

**Pricing logic:**
```python
# Final price = Gross price × (100 - sum of all discounts) / 100
gross_price * (100.0 - (discount_1 + discount_2 + discount_3)) / 100.0
```

Then floor/ceiling logic: if the discounted price falls below the floor, use the floor; if it exceeds the ceiling, use the ceiling.

**Real-world example:**
- Gross price: $0.15 per kWh
- Discount 1: 5%, Discount 2: 2%, Discount 3: 0%
- Discounted price: $0.15 × (100 - 7) / 100 = $0.1395
- Floor tariff: $0.12, Ceiling tariff: $0.14
- Final price: $0.1395 (it's between floor and ceiling, so no adjustment)

### How Meter Readings Are Stored and Disaggregated

**Stored in Snowflake** in the `fct_finance_meter_readings_current` and `dim_finance_meter_reading` tables.

| Field | Description |
|-------|-------------|
| `OPENING_READING` | Meter value at start of billing period |
| `CLOSING_READING` | Meter value at end of billing period |
| `UTILIZED_READING` | = closing - opening (what was consumed) |
| `DISCOUNT_READING` | Energy credits to subtract (negotiated allowances) |
| `SOURCED_ENERGY` | Self-generated energy to subtract (e.g., solar panels) |

**How they relate:**
```
UTILIZED_READING = CLOSING_READING - OPENING_READING
                   (This is raw consumption)

SITE_METER_ADJUSTED_READING = UTILIZED_READING - SOURCED_ENERGY - DISCOUNT_READING
                              (This is what gets billed)
```

**Real-world example:**
- Opening reading: 10,000 kWh
- Closing reading: 15,000 kWh
- Utilized reading: 5,000 kWh (they consumed 5,000 kWh)
- Sourced energy: 500 kWh (customer has solar panels)
- Discount reading: 200 kWh (negotiated free allowance)
- Adjusted reading: 4,300 kWh (what they actually pay for)

---

## 6. Real-World Data Interpretation

### Customer Table (`dim_finance_customer`)

**What it holds:** Who CBE sells energy to.

**Real customers from the data:**

| Code | Name | Country | Payment Terms |
|------|------|---------|---------------|
| NBL01 | Nigeria Breweries Limited | Nigeria | 60 days from end of month |
| QMM01 | QIT Madagascar Minerals SA | Madagascar | 75 days from end of billing month |
| UTK01 | Ekaterra Tea Kenya PLC | Kenya | 90 days from end of month |
| GBL01 | Guinness Ghana Breweries Limited | Ghana | 60 days from end of month |
| UNSOS | UN Support Office in Somalia | Somalia | 30 days from invoice |

**Type 2 SCD in action:** Customer `ZL01` (Zoodlabs Sierra Leone):
- Old record: Payment terms were `30EOM`, ended 2025-03-25, `DIM_CURRENT_RECORD = 0`
- New record: Payment terms changed to `30NET`, started 2025-03-25, `DIM_CURRENT_RECORD = 1`

This tracks that in March 2025, Zoodlabs renegotiated their payment terms.

### Contract Table (`dim_finance_contract`)

**What it holds:** The legal agreements between CBE and each customer.

**Real contracts from the data:**

| Contract | Customer | Type | Currency | Duration |
|----------|----------|------|----------|----------|
| CONKEN00-2021-00001 | UTK01 (Ekaterra Tea) | KWH | KES | 2021-2036 (15 years) |
| CONMAD00-2023-00001 | QMM01 (QIT Minerals) | KWH | USD | 2023-2043 (20 years) |
| CONCBCH0-2025-00002 | ZL02 (Zoodlabs) | RENTAL | USD | 2025-2035 (10 years) |
| CONKUBE0-2024-00001 | UNSOS (UN Somalia) | KWH | USD | 2024-2028 (4 years) |

**Business interpretation:** These are Power Purchase Agreements (PPAs) — long-term contracts where CBE installs solar infrastructure at customer sites and sells them the electricity generated.

### Contract Line Table (`dim_finance_contract_line`)

**What it holds:** The individual billable items within each contract.

**Real contract lines from the data:**

| Contract | Line | Product | Type |
|----------|------|---------|------|
| CONGHA00-2021-00002 | 4000 | Metered Energy (EMetered) - Phase 2 | Metered |
| CONMAD00-2023-00001 | 3000 | BESS Capacity Charge | N/A (fixed fee) |
| CONSLL02-2025-00003 | 3000 | Diesel Allocation - May 2025 | N/A |
| CONKEN00-2024-00013 | 1000 | Minimum Offtake | N/A |

**Business interpretation:**
- **Metered Energy** = Customer pays for actual kWh consumed (solar panels feeding their factory)
- **Available Energy** = Customer pays for capacity made available, regardless of use
- **BESS Capacity Charge** = Fixed fee for battery storage system
- **Minimum Offtake** = Contractual minimum the customer must pay even if they use less
- **Diesel Allocation** = Hybrid systems that include backup generators

### Meter Readings Table

**Real meter readings from the data (January 2025):**

| Customer | Site | Utilized | Discount | Sourced | What's billed |
|----------|------|----------|----------|---------|---------------|
| NBL01 (Nigeria Breweries) | Phase 2 Generator | 269,803 kWh | 0 | 3,014 kWh | 266,789 kWh |
| QMM01 (QIT Minerals) | Phase 1 | 1,049,534 kWh | 0 | 0 | 1,049,534 kWh |
| XFAB (Xflora Africa Blooms) | Metered | 18,387 kWh | 1,086 kWh | 0 | 17,301 kWh |
| XFL01 (Xpressions Flora) | Metered | 19,008 kWh | 1,024 kWh | 0 | 17,984 kWh |

**Business interpretation:**
- **Nigeria Breweries** has their own backup power source generating 3,014 kWh, so they only pay for the net 266,789 kWh from CBE
- **Xflora companies** have negotiated free energy allowances (possibly for being early customers or as contract sweeteners)

---

## 7. Complete Real-Life Scenario: QIT Madagascar Minerals SA (QMM01)

### Who They Are
A large mining company in Madagascar (likely titanium/mineral sands mining based on the name).

### The Contract: `CONMAD00-2023-00001`
- Started February 2023, runs until May 2043 (20-year PPA)
- Billed in USD
- Payment terms: 75 days from end of billing month (very generous — large customer)
- Tax rule: `EVT` (likely VAT exempt for mining operations)

### What They're Billed For (Contract Lines)

| Line | Product | Type | Business meaning |
|------|---------|------|------------------|
| 1000 | Metered Energy (EMetered) Phase 1 | Metered | Main solar installation, pay per kWh used |
| 2000 | Available Energy (EAvailable) Phase 1 | Available | Capacity fee for Phase 1 |
| 3000 | BESS Capacity Charge | Fixed | Battery storage system monthly fee |
| 5000 | Metered Energy (EMetered) Expanded PV | Metered | Second solar installation |
| 6000 | Available Energy (EAvailable) Expanded PV | Available | Capacity fee for expansion |
| 8000 | Expanded BESS Capacity Charge | Fixed | Additional battery storage |

### January 2025 Billing

| Product | Reading | To Bill |
|---------|---------|---------|
| Metered Energy Phase 1 | 1,049,534 kWh | 1,049,534 × price |
| Available Energy Phase 1 | 152,038 kWh capacity | 152,038 × price |

### What the Validation App Does
1. Pulls the pricing from the contract (gross price, discounts, floor/ceiling tariffs)
2. Pulls these meter readings
3. Calculates: `1,049,534 kWh × $0.XX per kWh = $YYY,YYY`
4. Compares to what Sage generated
5. Flags any discrepancy

---

## 8. Data Flow Architecture

```
┌─────────────────────┐
│  dim_finance_       │
│  customer           │──────┐
└─────────────────────┘      │
                             │
┌─────────────────────┐      │    ┌─────────────────────┐
│  dim_finance_       │──────┼───▶│   Invoice           │
│  contract           │      │    │   Validation        │
└─────────────────────┘      │    │   App               │
                             │    │                     │
┌─────────────────────┐      │    │   Compares:         │
│  dim_finance_       │──────┤    │   • Expected amount │
│  contract_line      │      │    │   • Sage amount     │
└─────────────────────┘      │    │   • Flags errors    │
                             │    └─────────────────────┘
┌─────────────────────┐      │
│  meter_readings     │──────┘
└─────────────────────┘

         +

┌─────────────────────┐
│  Exchange rates     │──────────▶  (User enters manually)
└─────────────────────┘

┌─────────────────────┐
│  Pricing config     │──────────▶  (From Sage ERP)
│  (gross, discounts, │
│   floor, ceiling)   │
└─────────────────────┘
```

---

## 9. Reverse-Engineered Data Architecture

This section reconstructs the complete data architecture underlying the Invoice Validation App by tracing every SQL query in the Python source code back to its Snowflake tables, joins, and schemas.

### 9.1 End-to-End Data Flow

```
┌──────────────────────┐     ┌───────────────────┐     ┌──────────────────────┐     ┌──────────────────────┐     ┌──────────────────────┐
│  Physical Meters /   │────▶│   Sage ERP        │────▶│  ETL (Extract,       │────▶│  Snowflake DWH       │────▶│  Invoice Validation  │
│  Inverters / BESS    │     │  (System of       │     │  Transform, Load)    │     │  dev.dwh + raw.manual│     │  App (Streamlit +    │
│                      │     │   Record)         │     │  Pipeline            │     │                      │     │   Snowpark)          │
└──────────────────────┘     └───────────────────┘     └──────────────────────┘     └──────────────────────┘     └──────────────────────┘
```

- **Physical assets** (solar panels, BESS, generators) produce meter readings at customer sites
- **Sage ERP** is the system of record for contracts, customers, pricing, meter readings, and invoices
- **ETL (Extract, Transform, Load) Pipeline** (references in the code to dbt (data build tool) views suggest dbt is used) transforms Sage data into the Kimball dimensional model
- **Snowflake** hosts the dimensional warehouse in `dev.dwh` and user-entered data in `raw.manual`
- **Streamlit + Snowpark** app reads from both schemas and provides the validation UI

### 9.2 Snowflake Schema Layout

The app operates across **two Snowflake schemas**:

| Schema | Purpose | Access Pattern |
|--------|---------|----------------|
| `dev.dwh` | Kimball dimensional model — all `dim_*` and `fct_*` tables | Read-only from the app. Written by the ETL pipeline. |
| `raw.manual` | User-entered data that doesn't originate in Sage | Read + Write from the app. Only exchange rates live here. |

Most queries use unqualified table names (e.g., `dim_finance_contract`) because the Snowpark session defaults to `dev.dwh`. The `get_specific_invoice()` function is the exception — it uses fully-qualified names like `dev.dwh.fct_invoice_line_item_current`, confirming the default schema.

### 9.3 Complete Table Inventory

#### Dimension Tables (9 tables)

| # | Table | Business Purpose | Key Columns | Grain |
|---|-------|-----------------|-------------|-------|
| 1 | `dim_finance_contract` | Legal agreements (PPAs) between CBE and customers | `dim_finance_contract_id`, `contract_number`, `customer_number`, `facility`, `contract_currency`, `active`, `dim_current_record` | One row per contract version (SCD2) |
| 2 | `dim_finance_contract_line` | Individual billable items within a contract | `dim_finance_contract_line_id`, `contract_number`, `contract_line`, `product_desc`, `active_status`, `effective_start_date`, `effective_end_date`, `price_adjust_date`, `dim_end_date` | One row per contract line version (SCD2) |
| 3 | `dim_finance_customer` | Customer master data | `dim_finance_customer_id`, `customer_number` | One row per customer version (SCD2) |
| 4 | `dim_finance_product_code` | Product code lookup (energy types, charges) | `dim_finance_product_code_id`, `product_code` | One row per product code |
| 5 | `dim_finance_meter_reading` | Meter reading metadata (dates, status) | `dim_finance_meter_reading_id`, `start_date`, `end_date`, `bill_date`, `active_status` | One row per meter reading period version |
| 6 | `dim_measure` | Measure/metric definitions (gross price, discounts, tariffs) | `dim_measure_id`, `measure_id`, `measure_short_name` | One row per measure type |
| 7 | `dim_invoice` | Invoice header data | `dim_invoice_id`, `invoice_number`, `invoice_date`, `invoice_category_description` | One row per invoice |
| 8 | `dim_finance_line_item_desc` | Invoice line item description lookup | `dim_finance_line_item_desc_id`, `invoice_item_description` | One row per description |
| 9 | `dim_finance_pricing_adjust_config` | Price adjustment configuration (frequency, direction, type) | `dim_finance_pricing_adjust_config_id`, `price_adjust_freq_desc`, `price_adjust_column_desc`, `price_adjust_direction_desc`, `price_adjust_type_desc`, `price_adjust_auto_desc`, `floating_price_reference_desc` | One row per adjustment config |

#### Fact Tables (4 tables)

| # | Table | Business Purpose | Key Columns | Grain |
|---|-------|-----------------|-------------|-------|
| 1 | `fct_finance_contract_lines_current` | Current-state snapshot of contract line measures (prices, discounts, tariffs) | FK to all dims, `measure_value`, `fct_current_record` | One row per contract line × measure (current only) |
| 2 | `fct_finance_contract_lines_full_history` | Full SCD2 history of contract line measures | Same as above + `fct_end_date` | One row per contract line × measure × version |
| 3 | `fct_finance_meter_readings_current` | Current meter readings per contract line per billing period | FK to dims, `opening_reading`, `closing_reading`, `utilized_reading`, `discount_reading`, `sourced_energy` | One row per contract line × billing period (current only) |
| 4 | `fct_invoice_line_item_current` | Current invoice line items from Sage | FK to dims, `quantity`, `unit_price_local`, `net_unit_price_local`, `tax_amount_local`, `line_item_amount_local`, `discount_amount_local` + USD equivalents | One row per invoice × line item (current only) |

#### Manual Table (1 table)

| # | Table | Schema | Business Purpose | Key Columns | Grain |
|---|-------|--------|-----------------|-------------|-------|
| 1 | `invoice_validation_exchange_rates` | `raw.manual` | USD-to-local currency exchange rates entered by users | `from_currency`, `to_currency`, `exchange_date`, `exchange_rate`, `added_by`, `added_when` | One row per currency pair × date × entry (append-only, deduplicated on read) |

### 9.4 Table Relationships / Star Schema Diagrams

The tables form **three distinct star schemas**, each centered on a fact table:

#### Star Schema 1: Contract Pricing Facts

```
                    ┌──────────────────────────┐
                    │  dim_finance_contract     │
                    └────────────┬─────────────┘
                                 │
┌──────────────────────────┐     │     ┌──────────────────────────┐
│  dim_finance_product_code│─────┼─────│  dim_measure             │
└──────────────────────────┘     │     └──────────────────────────┘
                                 │
                    ┌────────────┴─────────────┐
                    │  fct_finance_contract_    │
                    │  lines_current           │
                    │  (or _full_history)       │
                    └────────────┬─────────────┘
                                 │
┌──────────────────────────┐     │     ┌──────────────────────────────────┐
│  dim_finance_contract_   │─────┘     │  dim_finance_pricing_adjust_     │
│  line                    │           │  config                          │
└──────────────────────────┘           └──────────────────────────────────┘
```

**Join keys:** `dim_finance_contract_id`, `dim_finance_contract_line_id`, `dim_finance_product_code_id`, `dim_measure_id`, `dim_finance_pricing_adjust_config_id`

#### Star Schema 2: Meter Reading Facts

```
                    ┌──────────────────────────┐
                    │  dim_finance_meter_       │
                    │  reading                  │
                    └────────────┬─────────────┘
                                 │
                    ┌────────────┴─────────────┐
                    │  fct_finance_meter_       │
                    │  readings_current         │
                    └────────────┬─────────────┘
                                 │
                    ┌────────────┴─────────────┐
                    │  dim_finance_contract_    │
                    │  line                     │
                    └──────────────────────────┘
```

**Join keys:** `dim_finance_meter_reading_id`, `dim_finance_contract_line_id`

#### Star Schema 3: Invoice Line Item Facts

```
┌──────────────────────────┐                    ┌──────────────────────────┐
│  dim_invoice             │                    │  dim_finance_customer    │
└────────────┬─────────────┘                    └────────────┬─────────────┘
             │                                               │
             └──────────────┬────────────────────────────────┘
                            │
               ┌────────────┴─────────────┐
               │  fct_invoice_line_item_   │
               │  current                  │
               └────────────┬─────────────┘
                            │
             ┌──────────────┴────────────────────────────────┐
             │                                               │
┌────────────┴─────────────┐                    ┌────────────┴─────────────┐
│  dim_finance_product_    │                    │  dim_finance_line_item_  │
│  code                    │                    │  desc                    │
└──────────────────────────┘                    └──────────────────────────┘
```

**Join keys:** `dim_invoice_id`, `dim_finance_customer_id`, `dim_finance_product_code_id`, `dim_finance_line_item_desc_id`

### 9.5 SCD2 Versioning Pattern

The warehouse implements **Slowly Changing Dimension Type 2** at two levels:

#### Dimension-Level SCD2

Used on `dim_finance_contract`, `dim_finance_contract_line`, `dim_finance_customer`:

| Field | Purpose |
|-------|---------|
| `dim_current_record` | `1` = current version, `0` = historical version |
| `dim_end_date` | Date this version was superseded (used in `get_recent_contract_changes`) |

The app filters for current records with `WHERE dim_current_record = 1` in `get_current_contracts()`.

#### Fact-Level SCD2

Used on `fct_finance_contract_lines_full_history`:

| Field | Purpose |
|-------|---------|
| `fct_current_record` | `1` = current fact version, `0` = superseded |
| `fct_end_date` | Date this fact version was closed out |

The app uses `fct_end_date > dateadd(month, -3, current_date)` in `get_recent_contract_changes()` to find recently-changed pricing.

#### Current vs Full-History Table Pairs

| Current Table | Full-History Table | Relationship |
|---------------|-------------------|--------------|
| `fct_finance_contract_lines_current` | `fct_finance_contract_lines_full_history` | Current = pre-filtered view where `fct_current_record = 1` |

The app uses the **current** table for validation (latest pricing) and the **full-history** table for auditing (what changed recently).

### 9.6 Sage ERP as System of Record

**Sage owns** all of the following data that flows into the dimensional warehouse:

| Data Domain | Sage Module | DWH Destination |
|-------------|-------------|-----------------|
| Contracts & pricing | Contract Management | `dim_finance_contract`, `dim_finance_contract_line`, `fct_finance_contract_lines_*` |
| Customers | Accounts Receivable | `dim_finance_customer` |
| Product codes | Product Master | `dim_finance_product_code` |
| Meter readings | Billing / Metering | `dim_finance_meter_reading`, `fct_finance_meter_readings_current` |
| Invoices | Invoicing | `dim_invoice`, `dim_finance_line_item_desc`, `fct_invoice_line_item_current` |
| Measures & pricing config | Configuration | `dim_measure`, `dim_finance_pricing_adjust_config` |

The **only data not from Sage** is exchange rates, which users enter manually through the app into `raw.manual.invoice_validation_exchange_rates`.

### 9.7 The `raw.manual` Schema

This schema exists specifically for data that the finance team needs to provide that isn't available in Sage:

| Aspect | Detail |
|--------|--------|
| **Purpose** | Store USD-to-local exchange rates for invoice validation |
| **Write access** | The app's `insert_new_exchange_rate_data()` function — the only write operation in the entire application |
| **Audit fields** | `added_by` (user email from Streamlit session) and `added_when` (timestamp at insert) |
| **Deduplication** | Reads use `ROW_NUMBER() OVER (PARTITION BY from_currency, to_currency, exchange_date ORDER BY added_when DESC)` to get only the most recent entry per currency pair per date |
| **Pattern** | Append-only inserts (no UPDATEs or DELETEs). Users "update" a rate by inserting a new row; the read query automatically picks the latest. |

This means the table grows monotonically — every exchange rate ever entered is preserved as an audit trail, and the deduplication logic on read ensures the latest value is always used.

---

## 10. Function Map

This section maps every function in `Invoice_Validation_App.py` to its role in the data architecture, the tables it queries, and its position in the application's call graph.

### 10.1 Architecture Layer Overview

The 14 functions in the app fall into four architectural layers:

| Layer | Purpose | Functions |
|-------|---------|-----------|
| **Data Access** | SQL queries against Snowflake | `get_current_contracts`, `get_pricing_adjustments`, `get_current_contract_pricing`, `get_current_meter_readings`, `get_recent_contract_changes`, `get_specific_invoice`, `get_exchange_rates`, `insert_new_exchange_rate_data` |
| **Business Logic** | Calculations and transformations in Python/Pandas | `apply_price_adjust_date_logic`, `derive_local_and_usd_final_prices`, `calculate_invoice_line_item_amounts` |
| **Orchestration** | Coordinates data access + business logic into a pipeline | `conduct_analysis_for_given_contracts` |
| **Presentation** | Formats output for Streamlit UI | `rename_dataframe_columns`, `list_of_end_of_months` |

### 10.2 Application Execution Flow

```
                                  ┌─────────────────────────────────┐
                                  │        Application Start        │
                                  └─────────────┬───────────────────┘
                                                │
                                  ┌─────────────▼───────────────────┐
                                  │   get_current_contracts()       │  ← Loads all active contracts
                                  └─────────────┬───────────────────┘
                                                │
                              ┌─────────────────┼─────────────────────┐
                              │                 │                     │
                ┌─────────────▼───────┐  ┌──────▼──────────┐  ┌──────▼──────────────────┐
                │ list_of_end_of_     │  │ get_pricing_    │  │ get_recent_contract_    │
                │ months(6)           │  │ adjustments()   │  │ changes(customer)       │
                │ (date utility)      │  │ (Section 1 UI)  │  │ (Section 2 UI)          │
                └─────────────────────┘  └──────┬──────────┘  └─────────────────────────┘
                                                │
                                  ┌─────────────▼───────────────────┐
                                  │ apply_price_adjust_date_logic() │
                                  └─────────────────────────────────┘

                    ─ ─ ─ ─ ─ ─  Section 3: Validation Loop  ─ ─ ─ ─ ─ ─

          For each contract_number in all_contracts_list:

                                  ┌─────────────────────────────────────────────┐
                                  │  conduct_analysis_for_given_contracts()     │
                                  └─────────────┬───────────────────────────────┘
                                                │
                          ┌─────────────────────┼─────────────────────┐
                          │                     │                     │
            ┌─────────────▼───────┐  ┌──────────▼────────┐  ┌────────▼──────────────────┐
            │ get_exchange_rates()│  │ get_specific_     │  │ get_current_contract_     │
            │                    │  │ invoice()         │  │ pricing()                 │
            └────────────────────┘  └───────────────────┘  └────────┬──────────────────┘
                                                                    │
                                                          ┌─────────▼──────────────────┐
                                                          │ derive_local_and_usd_      │
                                                          │ final_prices()             │
                                                          └────────────────────────────┘
                                                                    │
                                                ┌───────────────────┼────────────────────┐
                                                │                                        │
                                  ┌─────────────▼───────────┐              ┌─────────────▼───────────┐
                                  │ get_current_meter_      │              │ calculate_invoice_      │
                                  │ readings()              │─────────────▶│ line_item_amounts()     │
                                  └─────────────────────────┘              └─────────────────────────┘
```

### 10.3 Function Reference

---

#### 1. `get_current_contracts()`

| Attribute | Detail |
|-----------|--------|
| **Line** | 29 |
| **Layer** | Data Access |
| **Signature** | `get_current_contracts() → pd.DataFrame` |
| **Business Purpose** | Loads all currently active contracts to populate the contract list used throughout the app |
| **Tables Queried** | `dim_finance_contract` |
| **Join Pattern** | Single table, no joins |
| **Key Filters** | `dim_current_record = 1 AND active = 1` |
| **Returns** | DataFrame of active contracts with `CONTRACT_NUMBER`, `CUSTOMER_NUMBER`, `FACILITY`, `CONTRACT_CURRENCY` |
| **Called By** | Main script (app startup, line 610) |
| **Calls** | None |
| **Architecture Role** | Bootstrap function — provides the contract universe that drives every other query |

---

#### 2. `apply_price_adjust_date_logic(df)`

| Attribute | Detail |
|-----------|--------|
| **Line** | 39 |
| **Layer** | Business Logic |
| **Signature** | `apply_price_adjust_date_logic(df: pd.DataFrame) → pd.DataFrame` |
| **Business Purpose** | Transforms the historical `PRICE_ADJUST_DATE` (the original start date of price adjustments) into the next upcoming adjustment date, based on the configured frequency (Month or Year) |
| **Tables Queried** | None (pure DataFrame transformation) |
| **Key Logic** | For `Year` frequency: replaces year with current year (or next year if already passed). For `Month` frequency: replaces month with current month. Null-ifies dates before 2000-01-01 as sentinel values. |
| **Returns** | Same DataFrame with `PRICE_ADJUST_DATE` column updated to next upcoming date |
| **Called By** | `get_pricing_adjustments()` |
| **Calls** | None |
| **Architecture Role** | Date projection logic — converts a static config date into a rolling "next adjustment" date |

---

#### 3. `get_pricing_adjustments()`

| Attribute | Detail |
|-----------|--------|
| **Line** | 91 |
| **Layer** | Data Access |
| **Signature** | `get_pricing_adjustments() → pd.DataFrame` |
| **Business Purpose** | Retrieves the pricing adjustment configuration for all active contract lines, including adjustment frequency, direction, and type. Powers the "Contract Pricing Adjustments" section of the UI. |
| **Tables Queried** | `fct_finance_contract_lines_current`, `dim_finance_contract_line`, `dim_finance_product_code`, `dim_finance_contract`, `dim_finance_pricing_adjust_config` |
| **Join Pattern** | 5-table inner join: fact → contract line → product code → contract → pricing config |
| **Key Filters** | `active_status = 1` on contract lines |
| **Returns** | DataFrame with contract info, product codes, and pricing adjustment config (frequency, direction, type, auto/manual) |
| **Called By** | Main script (Section 1 UI, line 642) |
| **Calls** | `apply_price_adjust_date_logic()` |
| **Architecture Role** | Powers the pricing adjustment tracker, showing upcoming and recent price changes |

---

#### 4. `get_current_contract_pricing(contract_number)`

| Attribute | Detail |
|-----------|--------|
| **Line** | 149 |
| **Layer** | Data Access |
| **Signature** | `get_current_contract_pricing(contract_number: str) → pd.DataFrame` |
| **Business Purpose** | Retrieves the complete current pricing structure for a single contract — gross price, three discount tiers, floor/ceiling tariffs in both local and USD, and net price. Uses a PIVOT to convert row-per-measure into columnar format. |
| **Tables Queried** | `fct_finance_contract_lines_current`, `dim_measure`, `dim_finance_contract_line`, `dim_finance_product_code` |
| **Join Pattern** | 4-table inner join: fact → measure + contract line + product code |
| **Key Filters** | `measure_id IN (9 specific measures)`, `active_status = 1`, `contract_number = '{contract_number}'` |
| **SQL Technique** | 3-CTE chain: `pricing_logic_1` (base join) → `pricing_logic_1_pivot` (Snowflake PIVOT) → `pricing_logic_2` (calculates `discounted_gross_price`) |
| **Returns** | One row per contract line with columns: `GROSS_PRICE`, `DISCOUNT_1/2/3`, `FLOOR/CEILING_TARIFF_LOCAL/USD`, `NET_PRICE`, `DISCOUNTED_GROSS_PRICE` |
| **Called By** | `conduct_analysis_for_given_contracts()` |
| **Calls** | None |
| **Architecture Role** | Core pricing data access — the most complex query in the app. Extracts the EAV-modeled measures into a flat pricing table. |

---

#### 5. `derive_local_and_usd_final_prices(df_pricing, exchange_rate)`

| Attribute | Detail |
|-----------|--------|
| **Line** | 236 |
| **Layer** | Business Logic |
| **Signature** | `derive_local_and_usd_final_prices(df_pricing: pd.DataFrame, exchange_rate: float) → pd.DataFrame` |
| **Business Purpose** | Applies the exchange rate conversion and floor/ceiling tariff logic to derive the final billable price in both USD and local currency |
| **Tables Queried** | None (pure DataFrame transformation) |
| **Key Logic** | (1) Convert discounted gross price to USD via exchange rate. (2) Convert USD floor/ceiling to local via exchange rate. (3) If discounted price < floor → use floor. (4) If discounted price > ceiling → use ceiling. (5) Otherwise use discounted price. Uses `bfill` across `[floor, ceiling, discounted]` to implement the priority logic. |
| **Returns** | Same DataFrame with added columns: `EXCHANGE_RATE_CBE`, `DISCOUNTED_GROSS_PRICE_USD`, `FLOOR/CEILING_TARIFF_USED`, `FINAL_PRICE_USD`, `FINAL_PRICE_LOCAL` |
| **Called By** | `conduct_analysis_for_given_contracts()` |
| **Calls** | None |
| **Architecture Role** | Price finalization — applies the currency and constraint logic that determines what the customer actually pays per unit |

---

#### 6. `get_current_meter_readings(contract_number)`

| Attribute | Detail |
|-----------|--------|
| **Line** | 261 |
| **Layer** | Data Access |
| **Signature** | `get_current_meter_readings(contract_number: str) → pd.DataFrame` |
| **Business Purpose** | Retrieves all meter readings for a given contract, including opening/closing readings, utilized reading, discount reading, and sourced energy |
| **Tables Queried** | `fct_finance_meter_readings_current`, `dim_finance_meter_reading`, `dim_finance_contract_line` |
| **Join Pattern** | 3-table inner join: fact → meter reading dim + contract line dim |
| **Key Filters** | `contract_number = '{contract_number}'`, `active_status IS NULL OR active_status = 1` |
| **Returns** | DataFrame with columns: `CONTRACT_NUMBER`, `CONTRACT_LINE`, `START_DATE`, `END_DATE`, `BILL_DATE`, `OPENING_READING`, `CLOSING_READING`, `UTILIZED_READING`, `DISCOUNT_READING`, `SOURCED_ENERGY` |
| **Called By** | `conduct_analysis_for_given_contracts()` |
| **Calls** | None |
| **Architecture Role** | Consumption data access — provides the "what was used" side of the invoice calculation |

---

#### 7. `get_recent_contract_changes(customer_number)`

| Attribute | Detail |
|-----------|--------|
| **Line** | 290 |
| **Layer** | Data Access |
| **Signature** | `get_recent_contract_changes(customer_number: str) → pd.DataFrame` |
| **Business Purpose** | Retrieves a 3-month audit trail of pricing changes for a given customer. Uses the full-history fact table to show what values changed and when. |
| **Tables Queried** | `fct_finance_contract_lines_full_history`, `dim_measure`, `dim_finance_contract_line`, `dim_finance_product_code`, `dim_finance_contract` |
| **Join Pattern** | 5-table inner join: full-history fact → measure + contract line + product code + contract |
| **Key Filters** | `customer_number = '{customer_number}'`, `fct_end_date > dateadd(month, -3, current_date) OR dim_end_date > dateadd(month, -3, current_date)` |
| **Returns** | DataFrame with measure values, `CURRENT_VALUE` flag (derived from `fct_current_record`), and contract line metadata |
| **Called By** | Main script (Section 2 UI, line 669) |
| **Calls** | None |
| **Architecture Role** | Audit function — answers "what changed in the last 3 months?" using SCD2 history |

---

#### 8. `list_of_end_of_months(n_months)`

| Attribute | Detail |
|-----------|--------|
| **Line** | 327 |
| **Layer** | Presentation |
| **Signature** | `list_of_end_of_months(n_months: int) → list[date]` |
| **Business Purpose** | Generates a list of the last N month-end dates for the invoice month selector dropdown |
| **Tables Queried** | None (pure date utility) |
| **Key Logic** | Uses `pd.offsets.MonthEnd` to compute the last day of each of the previous N months |
| **Returns** | List of `datetime.date` objects (e.g., `[2025-01-31, 2024-12-31, ...]`) |
| **Called By** | Main script (line 615, called with `n_months=6`) |
| **Calls** | None |
| **Architecture Role** | UI helper — populates the billing period selector |

---

#### 9. `get_specific_invoice(invoice_date, customer_number)`

| Attribute | Detail |
|-----------|--------|
| **Line** | 333 |
| **Layer** | Data Access |
| **Signature** | `get_specific_invoice(invoice_date: str, customer_number: str) → pd.DataFrame` |
| **Business Purpose** | Retrieves the actual Sage-generated invoice for a specific customer and billing period. This is the "what Sage says" side of the validation comparison. |
| **Tables Queried** | `dev.dwh.fct_invoice_line_item_current`, `dev.dwh.dim_invoice`, `dev.dwh.dim_finance_customer`, `dev.dwh.dim_finance_product_code`, `dev.dwh.dim_finance_line_item_desc` |
| **Join Pattern** | 5-table join: fact → invoice (INNER) → customer (LEFT) → product code (LEFT) → line item desc (LEFT) |
| **Key Filters** | `invoice_date = '{invoice_date}'`, `customer_number = '{customer_number}'`, `invoice_category_description = 'Invoice'` |
| **Returns** | DataFrame with product code, description, quantity, unit prices (local + USD), tax amounts, line item amounts, discount amounts |
| **Called By** | `conduct_analysis_for_given_contracts()` |
| **Calls** | None |
| **Architecture Role** | Invoice retrieval — fetches the Sage output that gets compared against the independently calculated amounts |

**Note:** This is the only function that uses fully-qualified table names (`dev.dwh.`), and the only one using LEFT JOINs (because invoice data may have missing customer or product references).

---

#### 10. `calculate_invoice_line_item_amounts(pricing, meterreadings)`

| Attribute | Detail |
|-----------|--------|
| **Line** | 371 |
| **Layer** | Business Logic |
| **Signature** | `calculate_invoice_line_item_amounts(pricing: pd.DataFrame, meterreadings: pd.DataFrame) → pd.DataFrame` |
| **Business Purpose** | The core validation calculation. Merges pricing with meter readings and computes expected invoice amounts using two independent methods to detect rounding discrepancies. |
| **Tables Queried** | None (pure DataFrame transformation) |
| **Key Logic** | (1) Merge pricing + meter readings on `CONTRACT_NUMBER` + `CONTRACT_LINE`. (2) Calculate `SITE_METER_ADJUSTED_READING = UTILIZED - SOURCED_ENERGY - DISCOUNT_READING`. (3) **CBE method**: `FINAL_PRICE × SITE_METER_ADJUSTED_READING`. (4) **Sage method**: adjust price by ratio `(adjusted/utilized)`, round to 4dp, then `UTILIZED_READING × SAGE_ADJUSTED_PRICE`. (5) Non-energy products (`PRODUCT_CODE[:4] != 'ENER'`) use `FINAL_PRICE` as-is (fixed charges). |
| **Returns** | Merged DataFrame with both validated and Sage-simulated invoice amounts in local + USD |
| **Called By** | `conduct_analysis_for_given_contracts()` |
| **Calls** | None |
| **Architecture Role** | Validation engine — the function that actually answers "is this invoice correct?" |

---

#### 11. `get_exchange_rates(invoice_date)`

| Attribute | Detail |
|-----------|--------|
| **Line** | 448 |
| **Layer** | Data Access |
| **Signature** | `get_exchange_rates(invoice_date: str) → pd.DataFrame` |
| **Business Purpose** | Retrieves the most recent exchange rate entry for each currency pair for a given invoice date. Handles deduplication of multiple entries. |
| **Tables Queried** | `raw.manual.invoice_validation_exchange_rates` |
| **Join Pattern** | Single table with CTE for deduplication |
| **Key Filters** | `exchange_date = '{invoice_date}'`, `most_recent_entry = 1` (via ROW_NUMBER window function) |
| **SQL Technique** | `ROW_NUMBER() OVER (PARTITION BY from_currency, to_currency, exchange_date ORDER BY added_when DESC)` — picks the latest entry when a user has "updated" a rate by inserting a new row |
| **Returns** | DataFrame with one row per currency pair, columns: `FROM_CURRENCY`, `TO_CURRENCY`, `EXCHANGE_DATE`, `EXCHANGE_RATE`, audit fields |
| **Called By** | `conduct_analysis_for_given_contracts()`, Main script (Section 4 UI, line 742) |
| **Calls** | None |
| **Architecture Role** | Exchange rate reader — bridges the `raw.manual` schema into the validation pipeline |

---

#### 12. `insert_new_exchange_rate_data(data, user)`

| Attribute | Detail |
|-----------|--------|
| **Line** | 469 |
| **Layer** | Data Access |
| **Signature** | `insert_new_exchange_rate_data(data: pd.DataFrame, user: str) → bool` |
| **Business Purpose** | The only write operation in the entire application. Inserts new exchange rate rows into `raw.manual.invoice_validation_exchange_rates` with audit metadata. |
| **Tables Written** | `RAW.MANUAL.invoice_validation_exchange_rates` |
| **Write Pattern** | Row-by-row INSERT via `session.sql().collect()`. Appends `ADDED_BY` (user email) and `ADDED_WHEN` (current timestamp) to each row. |
| **Returns** | `True` on success |
| **Called By** | Main script (Section 4 UI, line 761) |
| **Calls** | None |
| **Architecture Role** | The sole data mutation point. Append-only write to the manual schema. |

**Note:** Uses string interpolation for SQL (`f-string INSERT`), which works in this controlled Snowpark context but would be a SQL injection risk in other environments.

---

#### 13. `conduct_analysis_for_given_contracts(df_contracts, contracts, invoice_month)`

| Attribute | Detail |
|-----------|--------|
| **Line** | 497 |
| **Layer** | Orchestration |
| **Signature** | `conduct_analysis_for_given_contracts(df_contracts: pd.DataFrame, contracts: list, invoice_month: date) → tuple[pd.DataFrame, ...]` |
| **Business Purpose** | The pipeline orchestrator. For each contract in the list: resolves the customer and currency, fetches exchange rates, retrieves Sage invoices, pulls pricing and meter readings, calculates expected amounts, and compares against actuals. |
| **Tables Queried** | Indirectly all tables (via sub-function calls) |
| **Key Logic** | (1) Look up exchange rate for the contract's currency. (2) Fetch Sage invoice. (3) Fetch pricing → apply exchange rate and floor/ceiling. (4) Fetch meter readings. (5) Calculate expected invoice amounts. (6) Filter to invoice month. (7) Merge expected vs actual on `PRODUCT_CODE + PRODUCT_DESC`. (8) Compare at 4dp precision. (9) Concatenate results across all contracts. |
| **Returns** | Tuple of 5 DataFrames: `(df_pricing, df_meter_readings, df_merged_month, df_invoice, compare)` |
| **Called By** | Main script (validation loop, line 780; customer analysis, line 888) |
| **Calls** | `get_exchange_rates()`, `get_specific_invoice()`, `get_current_contract_pricing()`, `derive_local_and_usd_final_prices()`, `get_current_meter_readings()`, `calculate_invoice_line_item_amounts()` |
| **Architecture Role** | The central orchestrator — ties all data access and business logic functions together into the complete validation pipeline |

---

#### 14. `rename_dataframe_columns(df)`

| Attribute | Detail |
|-----------|--------|
| **Line** | 589 |
| **Layer** | Presentation |
| **Signature** | `rename_dataframe_columns(df: pd.DataFrame) → pd.DataFrame` |
| **Business Purpose** | Converts DataFrame column names from `SNAKE_CASE` to `Title Case` for display in the Streamlit UI |
| **Tables Queried** | None (pure formatting utility) |
| **Key Logic** | `col.replace('_', ' ').title()` for each column |
| **Returns** | DataFrame with reformatted column names |
| **Called By** | Main script (used 8 times across all UI sections) |
| **Calls** | None |
| **Architecture Role** | Display formatter — ensures all Streamlit tables have human-readable headers |

---

### 10.4 Cross-Reference: Functions × Database Tables

The matrix below shows which functions read (R) or write (W) each database table.

| Function | `dim_finance_contract` | `dim_finance_contract_line` | `dim_finance_customer` | `dim_finance_product_code` | `dim_finance_meter_reading` | `dim_measure` | `dim_invoice` | `dim_finance_line_item_desc` | `dim_finance_pricing_adjust_config` | `fct_contract_lines_current` | `fct_contract_lines_full_history` | `fct_meter_readings_current` | `fct_invoice_line_item_current` | `raw.manual.exchange_rates` |
|----------|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| `get_current_contracts` | R | | | | | | | | | | | | | |
| `get_pricing_adjustments` | R | R | | R | | | | | R | R | | | | |
| `get_current_contract_pricing` | | R | | R | | R | | | | R | | | | |
| `get_current_meter_readings` | | R | | | R | | | | | | | R | | |
| `get_recent_contract_changes` | R | R | | R | | R | | | | | R | | | |
| `get_specific_invoice` | | | R | R | | | R | R | | | | | R | |
| `get_exchange_rates` | | | | | | | | | | | | | | R |
| `insert_new_exchange_rate_data` | | | | | | | | | | | | | | W |

**Key observations:**
- `dim_finance_contract_line` is the most-referenced table (5 functions)
- `dim_finance_product_code` is referenced by 4 functions
- Only one function (`insert_new_exchange_rate_data`) performs writes, and only to the `raw.manual` schema
- The `fct_finance_contract_lines_current` table is the workhorse fact table (3 functions)
- Functions that don't appear in this matrix (`apply_price_adjust_date_logic`, `derive_local_and_usd_final_prices`, `calculate_invoice_line_item_amounts`, `list_of_end_of_months`, `conduct_analysis_for_given_contracts`, `rename_dataframe_columns`) are pure Python/Pandas operations with no direct database access

---

## 11. Why This System Exists

CBE has complex billing:
- Multiple currencies across Africa
- Metered vs. capacity-based charges
- Discounts and self-generation credits
- Floor/ceiling price protections in contracts
- Long-term contracts with annual price adjustments

Sage ERP calculates invoices, but the finance team doesn't fully trust it because:
1. Sage uses a different rounding method that causes small discrepancies at high volumes
2. Contract amendments might not be entered correctly
3. Exchange rates might be wrong
4. Meter readings might have errors

---

## 12. Privacy Considerations for Using Claude with Sensitive Data

### How to Opt Out of Training Data Usage

**Step-by-Step Path:**
1. Open Claude.ai and click on your **profile icon / initials**
2. Go to **Settings**
3. Select the **Privacy** tab
4. Find the toggle labeled **"Help improve Claude"**
5. Turn it **OFF** — the toggle should move to the left and turn gray

### Key Facts

| Consideration | What It Means |
|---------------|---------------|
| **Your plan type matters** | Updates apply to Claude Free, Pro, and Max plans. They do not apply to services under Commercial Terms, including Claude for Work (Team and Enterprise plans), or API use. |
| **Default is ON** | Anthropic enabled this by default, so you need to take action to protect your privacy. |
| **Retention period** | If you opt out, you continue with the 30-day data retention period. If you leave it on, retention extends to 5 years. |
| **Incognito mode** | Incognito chats are not used to improve Claude, even if you have enabled Model Improvement in your Privacy Settings. |
| **Uploaded files via connectors** | It does not include raw content from connectors (e.g. Google Drive), including remote and local MCP servers, though data may be included if it's directly copied into your conversation with Claude. |

### Claude Code and API Data Training Policy

| How You Access Claude Code | Data Used for Training? | Action Required |
|---------------------------|------------------------|-----------------|
| **Free / Pro / Max account** | Yes, by default | Must opt out in Settings → Privacy |
| **Direct API (with API key)** | No | None — excluded by default |
| **Team / Enterprise plan** | No | None — excluded by default |
| **AWS Bedrock / Google Vertex** | No | None — excluded by default |
| **Claude for Work / Gov / Education** | No | None — excluded by default |

### Official Anthropic Documentation on API/Commercial Use

> "Commercial users (Team and Enterprise plans, API, 3rd-party platforms, and Claude Gov) maintain existing policies: Anthropic does not train generative models using code or prompts sent to Claude Code under commercial terms, unless the customer has chosen to provide their data to us for model improvement (for example, the Developer Partner Program)."

> "API data is never used for model training."

### Recommendations for Sensitive Business Data

1. **If using Claude.ai web interface**: Go to Settings → Privacy → Turn OFF "Help improve Claude"

2. **For future sensitive work**: Switch to Anthropic API authentication, which isn't subject to consumer training policies and operates under different data processing agreements

3. **Organizational use**: Consider Claude for Work / Enterprise, which has contractual guarantees against training on your data

4. **For immediate sensitive sessions**: Use **Incognito mode** for conversations involving confidential business data

---

## Document Information

- **Generated:** January 30, 2026
- **Updated:** February 11, 2026 — Added Section 9 (Reverse-Engineered Data Architecture) and Section 10 (Function Map)
- **Source:** Claude.ai conversation analysis
- **Subject:** CrossBoundary Energy Invoice Validation App
- **Files Analyzed:**
  - `Invoice_Validation_App.py`
  - `FrontierMind_Extracts_meter_readings.csv`
  - `FrontierMind_Extracts_dim_finance_customer.csv`
  - `FrontierMind_Extracts_dim_finance_contract.csv`
  - `FrontierMind_Extracts_dim_finance_contract_line.csv`
